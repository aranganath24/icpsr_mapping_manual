[["index.html", "A Guide to Mapping ICPSR Data in R Studio 1 Preface", " A Guide to Mapping ICPSR Data in R Studio Aditya Ranganath 2021-10-28 1 Preface This brief guide to mapping ICPSR data in R Studio was prepared as part of Aditya Ranganath’s ICPSR Visiting Representative Fellowship in the summer and fall of 2021. It can be used as a lesson plan for instructors, as well as a tool for self-study. "],["introduction.html", "2 Introduction 2.1 Motivation 2.2 Scope and Objectives", " 2 Introduction 2.1 Motivation Many of ICSPR’s datasets are available in tabular formats that are ready to be imported into standard statistical software packages for analysis. In many cases, it is possible to visualize the data in these tabular datasets on a map (even if such visualizations are not explicitly a part of the original analysis or the replication materials archived by ICPSR). In this tutorial, we will provide a brief example-driven overview of how ICPSR users can represent tabular information from an ICSPR dataset on a map, using the R programming language. The tutorial does not presuppose any previous experience with data analysis, visualization, or programming. Why map ICPSR data to begin with? Students and researchers often use data archived at ICPSR as a starting point for exploration and discovery. Indeed, the data that others have collected can often inspire novel questions and hypotheses. It is also the case that the social and political processes studied by the researchers who archive their data with ICPSR are intrinsically spatial; after all, these processes necessarily occur somewhere on the surface of the earth! Placing these social and political processes in their spatial context can therefore bring the data that is stored in tabular datasets to life in dramatic ways, helping us to quickly notice patterns, identify puzzles, and generate hypotheses that would have otherwise remained obscure. In addition to using ICPSR data to generate ideas and explore patterns in existing data, students and researchers may want to reuse ICPSR data and incorporate them into their own ongoing research projects; in reusing this data, they may find it helpful to make publishable maps that they can use in their own papers and projects. 2.2 Scope and Objectives By working through the following tutorial, students and researchers will learn how to spatially visualize existing ICPSR data, with a view towards exploring ICPSR datasets of interest, as well as creating publishable maps derived from ICPSR data that can be used in their papers and projects. The tutorial also includes practice exercises that can be used as part of a classroom exercise or homework assignment, or as an informal way to test one’s understanding. It is important to emphasize that this is not a tutorial on Geographic Information Systems (GIS) writ large, and we do not cover important GIS concepts such as map projections and coordinate reference systems. If you need to use advanced mapping and spatial analysis in your work, you should learn these technical foundations (which are beyond the scope of our lesson here). It is also not a tutorial on the principles of cartography, which is a complex art and science that is also beyond our scope; however, the tutorial will show you how to customize maps in R, and you can use these skills (after reading up on cartography on your own) to make maps that conform to sound cartographic design principles. Our goal here is not to make works of art, but to quickly create functional and informative maps that are useful to social scientists. "],["preliminaries-and-set-up.html", "3 Preliminaries and Set-Up 3.1 Data 3.2 R and R Studio Installation 3.3 The R Studio Interface 3.4 Install Packages 3.5 Load Libraries 3.6 Set Working Directory", " 3 Preliminaries and Set-Up 3.1 Data The ICPSR data we will be mapping in this tutorial comes from a dataset archived on openICPSR. In particular, the dataset we will be working with is entitled “Governments’ Responses to COVID-19”, and was collected by Simon Porcher, a researcher at the University of Paris. The dataset’s ICPSR landing page can be found here, and the full citation information is below: Porcher, Simon. Governments’ Responses to COVID-19 (Response2covid19). Ann Arbor, MI: Inter-university Consortium for Political and Social Research [distributor], 2020-11-08. https://doi.org/10.3886/E119061V6. This panel dataset provides information on public health and economic interventions initiated by national governments in response to the Covid-19 Pandemic. It provides data in monthly intervals from January 2020 to October 2020 for most of the world’s sovereign countries. One of the variables in the dataset is an index (computed based on other variables in the dataset), that reflects the extent of government economic interventions to provide their populations with material support during this period of the pandemic. The tutorial will explore how to display country-level variation, with respect to this index on the scope of government economic responses to Covid-19, on a world choropleth map. For more information on this index and how it was constructed, please see the dataset’s documentation. If you would like to follow along with the tutorial, please download the data that is provided at the dataset’s ICPSR landing page (linked above) to your computer, and save it in a new directory that is specifically dedicated to the tutorial. 3.2 R and R Studio Installation If you haven’t already, please go ahead and install R and R Studio. R and R Studio must be installed separately; you should install R first, and then R Studio. R is the bare-bones computing environment, while R Studio is a visually appealing and user-friendly interface that allows users to interact with this environment in an intuitive way. Once you have both installed, you don’t need to open up R and R Studio separately; you only need to interact with R Studio (which will run R in the background). The following subsections provide instructions on installing R and R Studio for the macOS and Windows operating systems. These instructions are taken from the “Setup” section of the Data Carpentry Course entitled R for Social Scientists. The Data Carpentry page also contains installation instructions for the Linux operating system; if you’re a Linux user, please refer to that page for instructions. The Appendix to Garret Grolemund’s book Hands on Programming with R provides an excellent overview of the R and R Studio installation process; you can access it here. 3.2.1 Windows Installation Instructions Download R from the CRAN website Run the .exe file that was just downloaded. Go to the R Studio download page and under Installers select the “Windows” option. Double click the file to install R Studio Open R Studio to make sure it works. 3.2.2 macOS Installation Instructions Download R from the CRAN website Select the .pkg file for the latest R version. Double click on the downloaded file to install R. It is also a good idea to install XQuartz, which some packages require. Go to the R Studio download page, and under Installers select the “macOS” option. Double click the file to install R Studio Open R Studio to make sure it works. 3.3 The R Studio Interface Now that we’ve installed and opened up R Studio, let’s familiarize ourselves with the R Studio interface. When we open up R Studio, we’ll see a window open that looks something like this: Figure 3.1: The R Studio Interface If your interface doesn’t look exactly like this, it shouldn’t be a problem; we would expect to see minor cosmetic differences in the appearance of the interface across operating systems and computers (based on how they’re configured). However, you should see four distinct windows within the larger R Studio interface: The top-left window is known as the Source. The Source window is where we can write our R scripts (including the code associated with this tutorial), and execute those scripts. We can also type in R code into the “Console” window (bottom-left window), but it is preferable to write our code in a script within the source window. That’s because scripts can be saved (while code written into the console cannot); writing scripts therefore allows us to keep track of what we’re doing, and facilitates the reproducibility of our work. Note that in some cases, we may not see a Source window when we first open R Studio. In that case, to start a new script, simply click the File button on the R Studio menu bar, scroll down to New File button, and then select R Script from the menu bar that opens up. It’s also worth noting that the outputs of certain functions will appear in the Source window. In the context of our tutorial, when we want to view our datasets, we will use the View() function, which will display the relevant data within a new tab in the Source window. The top-right window is the Environment/History pane of the R Studio interface. The “Environment” tab of this window provides information on the datasets we’ve loaded into R Studio, as well as objects we have defined (we’ll talk about objects more later in the tutorial). -The “History” tab of the window provides a record of the R commands we’ve run in a given session. The bottom-right window is the Files/Plots/Packages/Help/Viewer window. The “Files” tab displays our computer’s directories and file structures and allows us to navigate through them without having to leave the R environment. The “Plots” tab is the tab where we can view any visualizations (including maps) that we create. Within the “Plots” tab, make note of the “Zoom” button, which we can use to enlarge the display of our maps and visualizations if they’re too compressed in the “Plots” window. Also, note the “Export” button within the “Plots” tab (next to the “Zoom” button); we can use this button to export the displayed map to a .png or .jpeg file that can be used outside of R Studio (we can also export our visualizations programmatically; we’ll cover how to do so later in the tutorial). The “Packages” tab provides information on which packages have been installed, as well as which packages are currently loaded (more on packages in Section 3.4) The “Help” tab displays documentation for R packages and functions. If we want to know more about how a package or function work, we can simply type a “?” followed by the package or function’s name (no space between the question mark and the name) and relevant information will be displayed within the “Help” tab. The “Viewer” tab displays HTML output. If we write code that generates an HTML file, we can view it within the “Viewer” tab. This will be relevant in the context of creating and viewing dynamic maps, which we’ll cover in Section 4.7 of the tutorial. The bottom-left window is the Console/Terminal/Jobs window. The “Console” tab is where we can see our code execute when we run our scripts, as well as certain outputs produced by those scripts. In addition, if there are any error or warning messages, they will be printed to the “Console” tab. We can also type code directly into the console, but as we noted earlier, it is better practice to write our code in a script and then run it from there. The “Terminal”, “R Markdown” and “Jobs” tabs are not relevant for the tutorial. 3.4 Install Packages R is an open-source programming language for statistical computing that allows users to carry out a wide range of data analysis and visualization tasks (among other things). One of the big advantages of using R is that it has a very large user community among social scientists and statisticians, who frequently publish R packages. One might think of packages as workbooks of sorts, which contain a well-integrated set of R functions, scripts, data, and documentation; these “workbooks” are designed to facilitate certain tasks or implement given procedures. These packages are then shared with the broader community, and at this point, anyone who needs to accomplish the tasks to which the package addresses itself can use the package in the context of their own projects. The ability to use published packages considerably simplifies the work of applied social scientists using R; it means that they rarely have to write code entirely from scratch, and can build on the code that others have published in the form of packages. This allows applied researchers to focus on substantive problems, without having to get too bogged down in complicated programming tasks. In the context of this tutorial, generating maps of ICPSR data in R would be relatively complex if we had to write all our code from scratch. However, because we are able to make use of mapping and visualization packages written by other researchers, the task is considerably simpler, and will not require any complicated programming. In this tutorial, we will use a few packages to accomplish our goal of mapping tabular ICPSR data. They are: tmap: The tmap package will allow us to create and customize a publishable map. sf: The sf package allows us to work with spatially explicit data within R. rnaturalearth, rnaturalearthdata, rgeos: In order to visualize our data on a world map, we need a spatial dataset of the world’s country boundaries. One way to get such a dataset is to download it from a public repository, and then load it into R Studio. However, these packages allow us to load a spatial dataset of world boundaries into R Studio without having to actually download anything, which effectively saves us a few steps in the workflow. readxl: The readxl package (part of a broader suite of data science packages known as the “tidyverse”) will allow us to load the tabular ICPSR dataset, which is provided as an Excel file on the ICPSR landing page, into R Studio. dplyr: The dplyr package (also a part of the tidyverse) will allow us to efficiently transform the structure of the initial ICPSR dataset into a more tractable form that is conducive to mapping. To install a package in R, we can use the install.packages function. A function is essentially a programming construct that takes a specified input, runs this input (called an “argument”) through a set of procedures, and returns an output. In the code block below, the name of the package we want to install (here, “tmap”) is enclosed within quotation marks and placed within parentheses after printing install.packages Running the code below will effectively download the tmap package to our computer: # Installs &quot;tmap&quot; package install.packages(&quot;tmap&quot;) To run this code in your own R session: First, copy the code from the codeblock above (you can copy the code to your clipboard by hovering over the top-right of the code-block and clicking the “copy” icon; you can also highlight the code and copy from the Edit menu of your browser). Then, start a new R script within R Studio; if you want to keep a future record of your work, you may want to save this script to your computer (perhaps in the same folder to which you downloaded the tutorial data). We can save our scripts via the R Studio “File” menu. Paste the code into the script, highlight it, and click the “Run” button that is just above the Source window. Alternatively, instead of copying/pasting, you can manually type in the code from the codeblock into your script (manually typing in the code is slower, but often a better way to learn than copy/pasting). After you’ve run the code, watch the code execute in the console, and look for a message confirming that the package has been successfully installed. Below, we can see how that line of code should look in your script, and how to run it: Figure 3.2: Installing tmap in R Script Please note that you can follow along with the tutorial on your own computers by transferring all of the subsequent codeblocks into your script in just this way. Run each codeblock in your R Studio environment as you go, and you should be able to replicate the entire tutorial on your computer. Note that the codeblocks in the tutorial usually have a comment, prefaced by a hash (“#”). When writing code in R (or any other command-line interface) it is good practice to preface one’s code with brief comments that describe what a block of code is doing. Writing these comments can allow someone else (or your future self) to read and quickly understand the code more easily than otherwise might be the case. The hash before the comment effectively tells R that the subsequent text is a comment, and should be ignored when running a script If one does not preface the comment with a hash, R wouldn’t know to ignore the comment, and would throw an error message. Now, let’s install the other packages we mentioned above, using the same function: # Installs remainder of necessary packages to complete exercise install.packages(&quot;sf&quot;) install.packages(&quot;rnaturalearth&quot;) install.packages(&quot;rnaturalearthdata&quot;) install.packages(&quot;rgeos&quot;) install.packages(&quot;readxl&quot;) All of the packages we need are now installed! 3.5 Load Libraries However, while our packages are installed, they are not yet ready to use. Before we can use our packages, we must load them into our environment. We can think of the process of loading installed packages into a current R environment as analogous to opening up an application on your phone or computer after it has been installed (even after an application has been installed, you can’t use it until you open it!). To load (i.e. “open”) an R package, we pass the name of the package we want to load as an argument to the library function. For example, if we want to load the “tmap” package into the current environment, we can type: # Loads &quot;tmap&quot; package library(tmap) At this point, the full suite of the tmap package’s functionality is available for us to use. Now, let’s go ahead and load the remainder of the packages that we’ll need: # Loads remainder of packages library(sf) library(rnaturalearth) library(rnaturalearthdata) library(rgeos) library(readxl) library(dplyr) At this point, the packages are loaded and ready to go! One important thing to note regarding the installation and loading of packages is that we only have to install packages once; after a package is installed, there is no need to subsequently reinstall it. However, we must load the packages we need (using the library function) every time we open a new R session. In other words, if we were to close R Studio at this point and open it up later, we would not need to install these packages again (3.4), but would need to load the packages again (3.5). 3.6 Set Working Directory Before we can bring our data into R Studio and begin the tutorial, we have to specify that data’s location on our computer. This step is known as setting one’s working directory. Before setting the working directory, make sure that you’ve downloaded the ICPSR dataset, and have placed it in a directory (i.e. folder) on your computer that is specifically dedicated to this tutorial. If you’re unfamiliar with the concept of file paths, the easiest way to set your working directory is through the R Studio menu. To do so, follow these steps: First, Click on the “Session” menu on the R Studio menu bar at the top of your screen, and then scroll down to the “Set Working Directory” button in the menu that opens up. When you hover over the “Set Working Directory” button, a subsidiary menu that contains a button that says “Choose Directory” will open; click this “Choose Directory” button. In the dialog box that opens up, navigate to the directory that contains the ICPSR data, select it, and click “Open”. At this point, your working directory should be set! The graphic below demonstrates the process of setting one’s working directory through R Studio’s menus: Figure 3.3: Setting Working Directory Via Menus Alternatively, if you are familiar with the concept of file paths, and know the file path to the folder containing the downloaded ICPSR dataset, you can set the working directly using the setwd() function, where the argument to the function is the relevant file path enclosed in quotation marks. For example: # Sets working directory setwd(&quot;/Users/adityaranganath/Documents/git_repositories/icpsr_mapping_manual/tutorial_data&quot;) Note that you won’t want to copy and paste the above codeblock, since your file path will be different; be sure to replace the file path above with your own. "],["tutorial.html", "4 Tutorial 4.1 Load and View Data 4.2 Edit Spatial Data 4.3 Process ICPSR Tabular Data for Mapping 4.4 Join Datasets 4.5 Make a Print Map 4.6 Export Map 4.7 Make a Dynamic Map 4.8 Summary", " 4 Tutorial Now that we’ve taken care of these preliminary steps, we’re ready to begin the tutorial. The steps in the tutorial below will walk through the process of creating world choropleth maps (both print and interactive) based on the dataset discussed in the previous section. 4.1 Load and View Data This subsection discusses how to load the tutorial data into our R environment. There are two pieces of data we’ll need to load: The ICPSR tabular dataset on government policy responses to Covid-19 which we’ve already introduced A spatial dataset of world country boundaries; we will bring this dataset into R Studio via the ne_countries function of the rnaturalearth package We will discuss how to import the ICPSR Covid-19 data in Section 4.1.1, and how to import the spatial dataset of world country boundaries via rnaturalearth in Section 4.1.2. 4.1.1 ICPSR Covid-19 Tabular Data When importing tabular data that we have saved on our computer into R Studio, it’s important to first understand some of the details of the data we’re trying to import. The first thing to note is the type of file we’re working with, which is indicated by the file extension; here, we can note that the ICPSR data’s file extension “.xlsx”, which indicates that it’s an Excel file (but note that .xlsx files can also be opened in spreadsheet software programs other than Excel). As a result, we’ll have to import this dataset into R Studio using a function designed specifically to handle Excel files. To that end, we’ll use the read_excel function from the readxl package. Recall that if we want to learn more about a function or a package, it’s possible to simply type a question mark followed by the package or function name in the console, and relevant information will appear in the “Help” tab of the “Files/Plots/Packages/Help/Viewer” window on the bottom right of the R Studio interface. For example, if we wanted to learn more about the read_excelfunction, we could type ?read_excel into the console, and view the documentation in the “Help” tab. Before using the read_excel function to bring the data into our R Studio environment, it could be helpful to inspect the data outside of the R environment, and determine whether the dataset has any features that we have to account for when loading it into our R environment. When we open the downloaded spreadsheet, it will look something like this: Figure 4.1: ICPSR dataset in spreadsheet with description tab open Note that immediately after opening the spreadsheet, we will land on its first tab (or “sheet”), which is titled “Description”. This part of the spreadsheet effectively functions as a data codebook, which we can look through to understand the dataset’s various variables and and assess how they were measured. To open up the actual dataset, we can toggle to the “Dataset” tab by pressing the corresponding button on the bottom-left of the spreadsheet (highlighted in red below): Figure 4.2: ICPSR dataset open in spreadsheet software with dataset tab open The fact that the ICPSR dataset has two sheets within it is important; it means that when we load it into R, we’ll have to explicitly specify the sheet (i.e. the “Dataset” sheet) that we want to import. Now, let’s go ahead and load the “Dataset” sheet of the ICPSR data file into R Studio, using the following code: # Loads ICPSR data into R Studio read_excel(&quot;Gov_Responses2Covid19_last.xlsx&quot;, sheet=&quot;Dataset&quot;) As we noted above, read_excel is the function used to bring in Excel spreadsheet data into R. The function has two arguments; the first (Gov_Responses2Covid19_last.xlsx) is the name of the file we want to import, while the second (sheet=\"Dataset\") establishes that we specifically want to import the the “Dataset” sheet from that Excel file. If the importing process is successful, we will see the dataset print out into our R console. It will look something like this: # A tibble: 62,700 x 43 country geoid iso d cases deaths school school_local domestic domestic_local travel travel_partial &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aruba AW ABW 43831 0 0 0 0 NA NA NA NA 2 Aruba AW ABW 43832 0 0 0 0 NA NA NA NA 3 Aruba AW ABW 43833 0 0 0 0 NA NA NA NA 4 Aruba AW ABW 43834 0 0 0 0 NA NA NA NA 5 Aruba AW ABW 43835 0 0 0 0 NA NA NA NA 6 Aruba AW ABW 43836 0 0 0 0 NA NA NA NA 7 Aruba AW ABW 43837 0 0 0 0 NA NA NA NA 8 Aruba AW ABW 43838 0 0 0 0 NA NA NA NA 9 Aruba AW ABW 43839 0 0 0 0 NA NA NA NA 10 Aruba AW ABW 43840 0 0 0 0 NA NA NA NA # … with 62,690 more rows, and 31 more variables: travel_dom &lt;dbl&gt;, travel_dom_partial &lt;dbl&gt;, curf &lt;dbl&gt;, # curf_partial &lt;dbl&gt;, mass &lt;dbl&gt;, mass_partial &lt;dbl&gt;, elect &lt;dbl&gt;, elect_partial &lt;dbl&gt;, sport &lt;dbl&gt;, # sport_partial &lt;dbl&gt;, rest &lt;dbl&gt;, rest_local &lt;dbl&gt;, testing &lt;dbl&gt;, testing_narrow &lt;dbl&gt;, masks &lt;dbl&gt;, # masks_partial &lt;dbl&gt;, surveillance &lt;dbl&gt;, surveillance_partial &lt;dbl&gt;, state &lt;dbl&gt;, state_partial &lt;dbl&gt;, # cash &lt;dbl&gt;, wage &lt;dbl&gt;, credit &lt;dbl&gt;, taxc &lt;dbl&gt;, taxd &lt;dbl&gt;, export &lt;dbl&gt;, rate &lt;dbl&gt;, # Rigidity_Public_Health &lt;chr&gt;, Economic_Measures &lt;chr&gt;, population_2019 &lt;chr&gt;, continent &lt;chr&gt; Note that when printing a dataset to the console, R Studio will only display the first few records (i.e. rows) in the dataset, and won’t display all of the fields (i.e. columns) either, but rest assured that all of the information has been imported (when printing to the console, R Studio usually truncates the data because of space constraints). The code above successfully imported the data into R Studio; however, in order to easily work with the data in a scripting environment, we need to assign the data to something called an object. To understand the concept of object assignment, consider the following simple example: # assign value 5 to new object named x x&lt;-5 In the code above, we use R’s assignment operator, &lt;-, to assign the value 5 to an object named “x.” Now that an object named “x” has been created and assigned the value 5, printing “x” in our console (or printing “x” in our script and running it) will return the value 5: # View contents of object x x [1] 5 More generally, the process of assignment effectively equates the output created by the code on the right side of the assignment operator (&lt;-) to an object with a name that is specified on the left side of the assignment operator. Whenever we want to look at the contents of an object (i.e. the output created by the code to the right side of the assignment operator), we simply print the name of the object in the R console (or print the name and run it within a script). While the example above was very simple, we can assign virtually any R code, and by extension, the data structure(s) generated by that code (such as datasets, maps, graphs) to an R object. Indeed, we’ll use the basic principle of object assignment introduced above to assign our ICPSR dataset of interest to an object, which we will name “covid_data” (note that object names are arbitrary and could be virtually anything, but it is good practice for object names to describe their contents): # Imports &quot;Dataset&quot; sheet from ICPSR Excel file into R Studio, and assigns the dataset to an object named &quot;covid_data&quot; covid_data&lt;-read_excel(&quot;Gov_Responses2Covid19_last.xlsx&quot;, sheet=&quot;Dataset&quot;) The code above imports the dataset of interest using the code we used above (read_excel(\"Gov_Responses2Covid19_last.xlsx\", sheet=\"Dataset\"), but then takes the additional step of assigning the result of this expression (i.e. the imported ICPSR dataset) on the right side of the assignment operator to an object named covid_data. In other words, the code assigns the output of the expression that results from running read_excel(\"Gov_Responses2Covid19_last.xlsx\", sheet=\"Dataset\") (i.e. the ICPSR dataset) to an object named covid_data. We can confirm that the ICPSR dataset we imported has been assigned to an object named covid_data by typing and running covid_data in our script (or simply typing it into the console), and seeing that it prints the ICPSR dataset to our console: # Prints contents of &quot;covid_data&quot; object to the console covid_data # A tibble: 62,700 x 43 country geoid iso d cases deaths school school_local domestic domestic_local travel travel_partial &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aruba AW ABW 43831 0 0 0 0 NA NA NA NA 2 Aruba AW ABW 43832 0 0 0 0 NA NA NA NA 3 Aruba AW ABW 43833 0 0 0 0 NA NA NA NA 4 Aruba AW ABW 43834 0 0 0 0 NA NA NA NA 5 Aruba AW ABW 43835 0 0 0 0 NA NA NA NA 6 Aruba AW ABW 43836 0 0 0 0 NA NA NA NA 7 Aruba AW ABW 43837 0 0 0 0 NA NA NA NA 8 Aruba AW ABW 43838 0 0 0 0 NA NA NA NA 9 Aruba AW ABW 43839 0 0 0 0 NA NA NA NA 10 Aruba AW ABW 43840 0 0 0 0 NA NA NA NA # … with 62,690 more rows, and 31 more variables: travel_dom &lt;dbl&gt;, travel_dom_partial &lt;dbl&gt;, curf &lt;dbl&gt;, # curf_partial &lt;dbl&gt;, mass &lt;dbl&gt;, mass_partial &lt;dbl&gt;, elect &lt;dbl&gt;, elect_partial &lt;dbl&gt;, sport &lt;dbl&gt;, # sport_partial &lt;dbl&gt;, rest &lt;dbl&gt;, rest_local &lt;dbl&gt;, testing &lt;dbl&gt;, testing_narrow &lt;dbl&gt;, masks &lt;dbl&gt;, # masks_partial &lt;dbl&gt;, surveillance &lt;dbl&gt;, surveillance_partial &lt;dbl&gt;, state &lt;dbl&gt;, state_partial &lt;dbl&gt;, # cash &lt;dbl&gt;, wage &lt;dbl&gt;, credit &lt;dbl&gt;, taxc &lt;dbl&gt;, taxd &lt;dbl&gt;, export &lt;dbl&gt;, rate &lt;dbl&gt;, # Rigidity_Public_Health &lt;chr&gt;, Economic_Measures &lt;chr&gt;, population_2019 &lt;chr&gt;, continent &lt;chr&gt; This suggests that once we’ve created an object through the assignment process discussed above, we can reference an object’s contents by the object’s name. For example, in this case, we can refer to the ICPSR Covid-19 data that has been assigned to the covid_data object as covid_data within our scripts and documentation. In other words, due to the assignment operation, R is able to recognize that whenever we mention covid_data, we are referring to the underlying contents that have been assigned to the covid_data object (i.e. the ICPSR dataset). Throughout the tutorial, we’ll sometimes use object names to refer to the contents that they have been assigned; for instance, when we refer to covid_data or to the covid_data object, we are using shorthand for the ICPSR Covid-19 policy responses dataset that has been assigned to an object with this name. When we print covid_data in our console (or run it from our script), R will print only a snapshot of the covid_data object to the console. However, it will be useful to inspect the entire dataset of interest within the R interface (without having to open up Excel or other spreadsheet software). We can do so using the View function. In this case, to inspect the ICPSR dataset that we loaded into R Studio and assigned to covid_data, we can pass covid_data as an argument to the View function: # Opens &quot;covid_data&quot; object in R Studio&#39;s data viewer View(covid_data) This will open up the dataset in R Studio’s data viewer within a separate tab in the “Source” window. Within your R Studio environment, the result of running View(covid_data) will look something like this (dataset outlined in red): Figure 4.3: Viewing ICPSR Dataset in R Studio Data Viewer Note that it is possible to scroll up/down and across the dataset within the data viewer and explore its full dimensions (unlike when printing a dataset to the console). 4.1.2 Country Boundaries Spatial Data Now that we have our tabular data on government responses to Covid-19 loaded into R Studio and assigned to the object named covid_data, let’s now turn to the process of bringing spatial data on world country borders into memory. When working with spatial data in R, we will sometimes want to import data that is stored on our computer. There are several functions in the sf package that will allow us to easily import saved or downloaded spatial data into R; for more details, please consult the package’s documentation by typing ?sf in the console. In our case, however, we won’t have to download and import the spatial data we need into R Studio from our computer’s local drive. That is because there are R packages that already provide this spatial data, and allow us to directly load it into memory. In particular, we’ll use the ne_countries function of the rnaturalearth package to bring a spatial dataset of country borders into our R environment, and then assign it to an object that we will name country_boundaries: # Brings spatial dataset of country boundaries into R environment using the rnaturalearth package, and then assigns this dataset to an object named &quot;country_boundaries&quot; country_boundaries&lt;-ne_countries(scale=&quot;medium&quot;, returnclass=&quot;sf&quot;) Note the two arguments we pass to the ne_countries function: the scale argument specifies that we want to use a medium scale when rendering the map (the other options are ‘small’ and ‘large’), while the returnclass argument specifies that we want the spatial dataset in ‘sf’ format, which is a spatial data format that works well with the tmap mapping package (which we’ll introduce and use below). Now that we have this spatial dataset in memory and assigned to a new object named country_boundaries, let’s step back and clarify what exactly a spatial dataset is. In some respects, a spatial dataset is like a typical tabular dataset. To see this, let’s pass country_boundaries to the View() function to open up the dataset: # Opens contents of &quot;country_boundaries&quot; object in R Studio&#39;s data viewer View(country_boundaries) By scrolling across the dataset, we’ll note that each row corresponds to a country, and that there are many columns that correspond to various country-level attributes. The crucial column, however, which makes this a spatial dataset (as opposed to merely a tabular one), is the information contained in a column called “geometry”. This column contains geographic coordinate information that essentially defines a polygon for each country in the dataset. The “geometry” column is likely one of the last columns in the dataset, so we may have to scroll a bit to find it. Alternatively, we can use the relocate function in the dplyr package to make the “geometry” column the first column in country_boundaries, and then view this reordered dataset using the View function. # Moves &quot;geometry&quot; column to the beginning of the &quot;country_boundaries&quot; dataset View(relocate(country_boundaries, geometry)) The first argument passed to the relocate function (country_boundaries) indicates the object we want to manipulate using the relocate function, while the second argument (geometry) indicates the name of the column in country_boundaries that we want to move up to the front of the dataset. Once that column relocation has taken place, the View function brings up the amended dataset as a new tab in the source window. It will look something like this (note the “geometry” column): Figure 4.4: Geometry Column Contains Spatial Information We can use the information in the “geometry” column to draw georeferenced polygons for each row in the spatial dataset, which will yield a world map! To translate the information in the geometry tab into a cartographic representation, we’ll use a package called tmap. In particular, we’ll use the tm_shape and tm_polygons functions from tmap, which are connected by a plus sign (+). The argument passed to the tm_shape function is the name of the object associated with the spatial dataset (country_boundaries, defined above). In addition, the tm_polygons function indicates that the spatial data is to be represented using polygons (as opposed to alternatives such as lines or points), and does not require any arguments. When we type in and run the following code from our script, the result is a map that is rendered based on the information in the “geometry” column of country_boundaries: # maps geographic features (i.e. countries) of &quot;country_boundaries&quot; using tmap package functions tm_shape(country_boundaries)+ tm_polygons() We can assign this map, rendered from country_boundaries using tmap, to a distinct object, just as we assigned the tabular ICPSR dataset and the spatial dataset to distinct objects (covid_data and country_boundaries, respectively). Let’s call this object worldmap; the code below performs this assignment: # assigns map of geographic features rendered from &quot;country_boundaries&quot; to a new object called &quot;worldmap&quot; worldmap&lt;-tm_shape(country_boundaries)+ tm_polygons() Having assigned the map to the worldmap object, we can bring up the map whenever we want by simply calling the worldmap object (i.e. printing worldmap and running it from our script): # displays contents of &quot;worldmap&quot; object (i.e. a country-level map generated from the &quot;country_boundaries&quot; spatial dataset) worldmap Within the R Studio interface, we can see the above map within the bottom-right window after selecting the “Plots” tab: Figure 4.5: World Map in ‘Plots’ Tab (Rendered from Spatial Dataset) We can enlarge the map in this window by clicking the “Zoom” link; this will produce an enlarged version of the map in a separate window: Figure 4.6: Enlarging Map with ‘Zoom’ Button 4.2 Edit Spatial Data We can edit spatial datasets in R Studio with relative ease, using commonly-used R packages. Let’s say, for example, that we don’t want Antarctica to appear on our map (since Antarctica typically does not appear on political maps of the world). To delete Antarctica from the map, we first need to delete the row that corresponds to Antarctica in country_boundaries. We can do so with the following code: # Deletes Antarctica from &quot;country_boundaries&quot; country_boundaries&lt;-country_boundaries %&gt;% filter(iso_a3 !=&quot;ATA&quot;) We can translate this code into ordinary language as follows: “Take the existing country boundaries dataset (country_boundaries to the left of the %&gt;% and to the right of the assignment operator) and then (%&gt;%, a symbol called a pipe, which is used to chain together code) select only the countries that are not Antarctica (filter(iso_a3 !=\"ATA\"). Take this amended (sans Antarctica) spatial dataset, and assign it back to an object named ‘country_boundaries’ (country_boundaries&lt;-); this assignment effectively overwrites the previous dataset that was assigned to country_boundaries (which did include Antarctica) with the amended dataset.” Two things may require additional elaboration: First is the pipe, the symbol that looks like this: %&gt;%. The pipe operator essentially takes the output of the code on its left, and then use that output as an input to the code on its right. Here, the pipe takes the country_boundaries object on its left, and then feeds this data into the filter function on its right. In other words, the pipe operator links the code on its two sides, and establishes that the data to be “filtered” within the filter function is country_boundaries. The filter function is a function from the dplyr package that allows one to select rows from a dataset using specified criteria. In our case, we want to select all rows from the dataset that are not Antarctica. The argument passed to the filter function, iso_a3 !=\"ATA\", is essentially saying “return any records where the”iso_a3\" variable (i.e. the 3 digit ISO country code) in the attribute table is NOT equal to “ATA” (Antarctica’s code). Note that != is R syntax for “not equal to”.1 Now, let’s see this change reflected in the corresponding map. To do so, we must update the worldmap object by rerunning the object assignment. That is, worldmap will not automatically reflect the edits we just made to the country_boundaries dataset. We need to run the code again (with the new version of country_boundaries passed through the tm_shape function) and then assign the revised map to worldmap, which effectively overwrites the previous map (the one with Antarctica) assigned to worldmap: # Makes a new map based on the edited &quot;country_boundaries&quot; dataset, and assigns this new map to the &quot;worldmap&quot; object (thereby overwriting the map with Antarctica that was previously assigned to &quot;worldmap&quot;) worldmap&lt;-tm_shape(country_boundaries)+ tm_polygons() Now, let’s view our updated map: # Display contents of updated &quot;worldmap&quot; object worldmap As desired, Antarctica no longer appears on the map associated with “country_boundaries”. 4.3 Process ICPSR Tabular Data for Mapping In order to represent the ICPSR data on governments’ economic responses to Covid-19 on a map, we must join the ICPSR dataset (covid_data) to the spatial dataset ( country_boundaries); at that point, we’ll have a new spatial dataset that will include the country-level Covid-19 data that we wish to map. We can then display the Covid-19 policy data on a map by using the tmap package that we have already introduced. Before we can take those steps, however, we need to process the ICPSR tabular data with a view towards facilitating the joining and mapping process. 4.3.1 Select Variables When working with data in R, it is often useful to get a quick sense of a given dataset’s dimensions, which we can do using the dim function. Below, we pass covid_data to the dim function: # ascertain dimensions of &quot;covid_data&quot; object dim(covid_data) [1] 62700 43 The output indicates that there are 62700 rows in the dataset, and 43 columns. This suggests that there are quite a few variables in the dataset, most of which we won’t need. In particular, given that we’re only interested in mapping (for now) the variable that represents an aggregate index of the generosity of governments’ economic support measures in response to the pandemic, we’ll go ahead and delete superfluous columns so as to keep the size of the final (joined) dataset tractable. The name of the variable we’d like to map, and therefore keep, is “Economic_Measure” (see the dataset’s documentation for more details). In addition to keeping this variable, we also need to keep the column titled “iso”, which is the 3-digit ISO country code; this ISO code also exists in the spatial dataset to which we want to join the “Economic_Measure” variable, and so we will use these ISO codes contained in the two datasets as the joining variable. Let’s create this smaller dataset, comprised of the ISO code and the economic intervention index that we want to map, and assign it to a new object named “covid_data_economic”: # Select &quot;iso&quot; and &quot;Economic_Measures&quot; columns from &quot;covid_data&quot; dataset, and assign the dataset created through this selection to the &quot;covid_data_economic&quot; object covid_data_economic&lt;-covid_data %&gt;% select(iso, Economic_Measures) The above code can be translated as follows: “Start with covid_data, and then (%&gt;%) keep the ‘iso’ and ‘Economic_Measures’ columns but discard everything else (`select(iso, Economic_Measures)). Assign this new 2-column dataset to a new object called covid_data_economic (covid_data_economic&lt;-).” We can take a look at this smaller dataset that was extracted from the original dataset by passing the covid_data_economic object as an argument to the now-familiar View function: # View contents of &quot;covid_data_economic&quot; object in R Studio data viewer View(covid_data_economic) Within the “Source” window, a new tab that contains the smaller 2-column dataset that’s been assigned to covid_data_economic will appear in the data viewer: Figure 4.7: New Dataset Based on Selection from Original Dataset Note that the original Covid-19 policy responses dataset, which we previously assigned to the covid_data object, is unaffected by our creation and assignment of a new dataset based on the selection of these two variables. We can confirm that this original data (covid_data) remains unaffected by inspecting it through a call to the View function: # View contents of &quot;covid_data&quot; object in R Studio data viewer View(covid_data) We can go back to the covid_data dataset anytime we need, but for now we’ll set it aside and start working with our newly created covid_data_economic dataset. 4.3.2 Change class of “Economic_Measures” Index Recall that the data we want to map is contained within the “Economic_Measures” column of covid_data_economic. R has six fundamental “types” of data: character, numeric, integer, logical, and complex. The code below extracts the “Economic_Measures” column from the dataset (placing a dollar sign in between the name of the object to which a dataset has been assigned, and the name of a column within that dataset, as in covid_data_economic$Economic_Measures, is a way of isolating and extracting a column from a larger dataset), and then passes it to the class function to identify the class of the data in the “Economic_Measures” field. # Find the class of the &quot;Economic_Measures&quot; field within the &quot;covid_data_economic&quot; dataset class(covid_data_economic$Economic_Measures) [1] &quot;character&quot; We can see from the above output that the class of the “Economic_Measures” variable is “character”, which implies that although the information in the “Economic_Measures” variable looks like it is numeric, R is not actually reading those data as numbers. So, we have to change the way in which that data is encoded, and ensure that it will be interpreted numerically; the failure to do this will prevent us from making numerical calculations using the information in this colum, as well as from mapping it using tmap. We can essentially recode the information in the “Economic_Measures” variable as “numeric” using the following expression: # Changes class of &quot;Economic_Measures&quot; field in &quot;covid_data_economic&quot; object from character to numeric covid_data_economic$Economic_Measures&lt;-as.numeric(covid_data_economic$Economic_Measures) In the code above, the expression to the right of the assignment operator extracts the “Economic_Measures” column from the the covid_data_economic dataset (covid_data_economic$Economic_Measures), and then changes this column’s class to numeric by passing it as an argument to the as.numeric function. The assignment operator then replaces the old version of the “Economic_Measures” column (encoded as character) within covid_data_economic, with this new (numeric) version of the “Economic_Measures” column. At this point, the “Economic_Measures” column in covid_data_economic is numeric; we can confirm this by passing that column through the class function once again: # Checks the class of the updated &quot;Economic_Measures&quot; field class(covid_data_economic$Economic_Measures) [1] &quot;numeric&quot; 4.3.3 Compute average of “Economic_Measures” index As we mentioned earlier, the ICPSR dataset on government policies with respect to Covid-19 is a cross-sectional time-series (i.e. panel) dataset, containing monthly observations over the course of about a year during the pandemic (January 2020 to October 2020). This means that we have to make some choices about how to represent the “Economic_Measures” index on a map. For example, do we want to pick data for a given month, and then map this data? Do we want to use the map to represent change across different months? Do we want to map a summary measure of the “Economic_Measures” data, such as the average index value across all the months in the sample? There are of many possibilities, but let’s choose to go ahead and map the country-level average for the “Economic_Measures” index across the entire time period covered in the dataset. That is, for each country, we’ll compute the average value of the monthly observations for the “Economic_Measures” index, and then map this average value. To that end, we need to take covid_data_economic, which contains monthly observations for each country, and collapse it into a new dataset that contains the country-level average of the “Economic_Measures” index. # Creates new dataset of country-level averages for &quot;Economic_Measures&quot; index, and then assigns this new dataset to a new object that is named &quot;covid_data_economic_avg&quot;. covid_data_economic_avg&lt;-covid_data_economic %&gt;% group_by(iso) %&gt;% summarize(mean_economic=mean(Economic_Measures, na.rm=FALSE)) Let’s unpack the code above, starting with the expression that’s to the right of the assignment operator. We start by calling the covid_data_economic object, which establishes that this is essentially the “base” dataset we wish to modify. Then (recall that the %&gt;% is used to chain together code by taking the output on the left and passing it as input into the code to its right), we call the group_by function, and pass iso as an argument to this function; this stipulates that all observations with the same ISO code are to be considered a group, and that any subsequent calculations will therefore be performed at the country level. This step ensures that when we calculate the mean of the “Economic_Measures” variable, the function will return the mean value of this index for each individual country, rather than the mean value for the dataset as a whole. After setting the grouping variable and using another pipe (%&gt;%) to establish that we are passing the newly grouped dataset as an input into the subsequent code, we call the summarize function. This function is used to create a new dataset that summarizes an existing dataset with relevant summary statistics (such as the mean or standard deviation). In particular, within the summarize function, we first need to create a name for the column that will contain the country-level averages for the “Economic_Measures” index in the new dataset. We’ll call this variable “mean_economic”, which corresponds to the very first part of the argument to the summarize function. We then set this variable equal to an expression that passes the “Economic_Measures” variable to the mean function. In essence, this expression calculates the mean of the “Economic_Measures” variable for each country (it calculates the country-level mean because we specified the grouping function, group_by(iso), in the previous line of code), and creates a column in the newly created dataset named “mean_economic” to store this information. The code that reads na.rm=FALSE simply stipulates that missing data should be ignored in the calculation of the mean value of the “Economic_Measures” index. Finally, this new dataset, consisting of two columns (one column containing ISO codes, and the other, named “mean_economic” containing the corresponding country-level mean of the “Economic_Measures” variable) is assigned to a new object called covid_data_economic_avg. We can translate the above code as follows: “Take the existing covid_data_economic dataset, and then group this dataset by the ISO country codes; then, generate a new dataset, containing one column with ISO country codes, and another column, named”mean_economic“, that contains information on the country-level mean of the ‘Economic_Measures’ index from the covid_data_economic dataset. Finally, assign this new dataset to an object called covid_data_economic_avg”. To inspect this new dataset within the Source window, simply pass covid_data_economic_avg to the View function. # Views contents of &quot;covid_data_economic_avg&quot; dataset in R Studio data viewer View(covid_data_economic_avg) We should see something that looks like this: Figure 4.8: Dataset of Country-Level Averages for ‘Economic_Measures’ Index 4.3.4 Calculate Summary Statistics Now that we have a new dataset (covid_data_economic_avg) containing the country-level average of the “Economic_Measures” index, it can be useful to get a sense of how this data (which is the data we’d like to map) is distributed. We can easily do this by using the summary function, which returns a table of summary statistics for a specified variable. The following code produces summary statistics for the “mean_economic” variable contained in covid_data_economic_average (which is referred to as covid_data_economic$mean_economic): # Produces table of summary statistics for &quot;mean_economic&quot; variable contained in &quot;covid_data_economic&quot; dataset summary(covid_data_economic_avg$mean_economic) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 0.0000 0.2787 0.3930 0.3853 0.5074 0.7236 30 4.4 Join Datasets We’re almost ready to map our data. But before doing that, we will have to join the covid_data_economic_avg object we just created to country_boundaries (i.e. the spatial dataset of country boundaries discussed earlier). In other words, before we can map our variable of interest on a world map, we must bring this variable into the spatially explicit country_boundaries dataset. The task of joining, or “merging” datasets is a very common procedure when working with social science data (or any data for that matter), since data is often held in many different locations, and must typically be brought together into a common dataset before it can be analyzed. That is essentially what we’re doing here. How do we join different datasets together? Associating two datasets into one larger dataset that combines information from both requires the datasets to share a common field; this common field can be used to essentially “glue” the datasets together. The International Organization for Standardization provides 3-digit country codes for each of the world’s countries that can be used to uniquely identify countries when working with country-level data. Both our spatial dataset (country_boundaries), and our dataset containing information on the “Economic_Measures” index averages (covid_data_economic_avg), contain fields with these standardized 3-digit ISO codes (this field is labelled “iso_a3” in the spatial dataset, and “iso” in the dataset containing the “Economic_Measures” average). We will therefore use the fields containing these 3-digit country codes to join covid_data_economic_avg to country_boundaries: # Join dataset with country-level means for the &quot;Economic_Measures&quot; index (i.e. &quot;covid_data_economic&quot;) to spatial dataset of world boundaries (i.e. &quot;country_boundaries&quot;), based on common 3-Digit ISO Codes; then, assign this dataset to an object named &quot;covid_economic_spatial_dataset&quot; covid_economic_spatial_dataset&lt;-full_join(country_boundaries, covid_data_economic_avg, by=c(&quot;iso_a3&quot;=&quot;iso&quot;)) In the code above, we use the full_join function to join covid_data_economic_avg to country_boundaries. The full_join function keeps all rows (i.e. observations) from both datasets, even if one dataset has observations that another one does not (and vice-versa). For more information on different join options, explore the documentation by inspecting the function’s documentation (?full_join). The first argument to the full_join function is country_boundaries, which is of course our spatial dataset. The second argument, covid_data_economic_avg is the tabular dataset containing information on country_level averages for the Covid economic intervention index (i.e. the data we ultimately want to map).2 The third argument specifies the join fields, i.e. the fields within the datasets that contain the common variable that can be used to correlate the records in the two different datasets and weld them together. In our case, the join variable is of course the 3-digit ISO country code. The argument that reads by=c(\"iso_a3\"=\"iso\") indicates that we want to join the datasets based on the set of country identifiers given by the 3-digit ISO codes; because the name of the column containing the 3-digit codes is different in the two datasets, the expression in the parentheses \"iso_a3\"=\"iso\" simply indicates that the column named “iso_a3” (in the spatial dataset) and the column named (iso) in the tabular dataset are equivalent to each other, and are to be used as the join fields. If they didn’t have different names–for example, if the ISO codes were in a column named “iso” in both datasets–we could simply have written by=iso to specify the join column. Finally, we take our newly created dataset, which adds the data we want to map our original spatial dataset (country_boundaries), and assign this value to a new object, named covid_economic_spatial_dataset. We can translate the code in the previous code block as follows: “Join covid_data_economic_avg to country_boundaries using the fields with 3-digit country ISO codes as the join fields (the column with ISO information in the spatial dataset is named ‘iso_a3’ while the column with ISO information in the tabular dataset is ‘iso’). Finally, assign the product of this join operation to a new object called covid_economic_spatial_dataset” Before proceeding, let’s take a quick look at our newly created joined dataset. To make it easy to inspect, we can move up the variables we’re interested in (country name, the “mean_economic” variable, and the geometry information that makes the data spatial in nature) up to the front of the dataset: # Bring the &quot;name&quot;, &quot;mean_economic&quot;, and &quot;geometry&quot; fields/columns in &quot;covid_economic_spatial_dataset&quot; to the front of the dataset covid_economic_spatial_dataset&lt;-covid_economic_spatial_dataset %&gt;% relocate(name, mean_economic, geometry) After moving these fields by using the relocate function with the relevant fields as arguments, pass worldmap_covid_data_economic, whose variables have now been relocated, to the familiar View function: # View the contents of the &quot;covid_economic_spatial_dataset&quot; in the R Studio data viewer View(covid_economic_spatial_dataset) The dataset that opens up in your Source window should look something like this: Figure 4.9: Spatial Dataset With Covid-19 Economic Index Data Note that we now have a spatial dataset of country boundaries (as indicated by the “name” and “geometry” fields), with the data we want to map (the mean, for each country, of the Covid-19 Economic intervention index during the period under consideration) now included as a column within an expanded spatial dataset. 4.5 Make a Print Map We’re finally ready to represent our ICPSR data on a map! To do so, we’ll use the tmap package, which we already used above to view a rendered version of our spatial dataset of country boundaries. Now, we’ll take it a step further, and actually represent our data on the map features (i.e. the countries on the world map). 4.5.1 Make a Preliminary Map Recall that as with with virtually anything else in R, we can assign maps created with the tmap package to objects, which makes it easy to subsquently reference our maps and customize them as needed. Below, we’ll create a rough draft of a map and assign it to an object named covid_economic_map: # Creates map based on the data contained within the &quot;mean_economic&quot; field of &quot;covid_economic&quot;spatial_dataset&quot;, and assigns this map to a new object called &quot;covid_economic_map&quot; covid_economic_map&lt;-tm_shape(covid_economic_spatial_dataset)+ tm_polygons(col=&quot;mean_economic&quot;, n=8, style=&quot;jenks&quot;, palette=&quot;BuGn&quot;) Above, in the expression that is to the right of the assignment operator, we first use tmap’s tm_shape function to specify the spatial dataset whose features we’d like to display. Within tmap, chaining together functions requires a + sign, so we add a + before moving to another function on the next line. This is the tm_polygons function, which we use because our spatial dataset of country boundaries represents those boundaries as polygons. Previously, we did not specify arguments to the tm_polygons function, but this function can take a variety of arguments that can help us to customize our map’s appearance; we’ll introduce a few more arguments below, but recall that if we want to see the full range of possible arguments, they are presented in the function’s documentation (?tm_polygons). Now, let’s consider the arguments that were passed to the tm_polygons function in the code above: col=\"mean_economic\" specifies the name of the column in the spatial dataset (which has been specified as an argument to the tm_shape function) that contains the data we’d like to map. Recall from the previous section that the name of this column is “mean_economic.” n=8 specifies that we want the data to be partitioned into 8 bins style=\"jenks\" indicates that we want to set break points in the data distribution using the Jenks Natural Breaks Classification; to see other options for partitioning your data, see the function’s documentation. For more information on the Jenks Natural Breaks Classification, as well as other data partition algorithms, see here. palette=\"BuGn\" specifies the color scheme that we want to use to represent the data. Check out this extremely useful guide on colors and palettes in R (including information on relevant color codes). “BuGn” refers to a blue-green color gradient, which we will use to represent country-level variation in the Covid economic index. To see what the map looks like, simply print covid_economic_map and run it in the script: # display contents of &quot;covid_economic_map&quot; covid_economic_map As in Section 4.1.2 above, we can see the map in the “Plots” tab of the bottom-right window, and can open up a larger window by clicking the “Zoom” button right below the “Plots” tab. Of course, the map we’ve just created needs a bit of work (most noticeably, the legend needs to be moved to a less distracting location), but after all of the previous work to set up our data, hopefully it feels exciting to finally see our tabular data transformed into a map! Before we work on the legend, let’s see how to change certain features of the map using arguments to the tm_polygons function that we’ve already discussed. For instance, let’s say we want a Yellow to Red palette (“YlOrRd”; again, remember you can look up these codes at the color guide linked above), only five intervals for the data, and want the data to be equally partitioned across intervals (rather than by using the Jenks algorithm). We’ll assign this modified map to a new object, titled covid_economic_map_alternative. # Modifies the appearance of &quot;covid_economic_map&quot; and assigns this modified map to a new object named &quot;covid_economic_map_alternative&quot; covid_economic_map_alternative&lt;-tm_shape(covid_economic_spatial_dataset)+ tm_polygons(col=&quot;mean_economic&quot;, n=5, style=&quot;equal&quot;, palette=&quot;YlOrRd&quot;) Let’s display this map and view its appearance; notice the change in color, the fewer number of classes, and the equal intervals in the legend: # Displays contents of &quot;covid_economic_map_alternative&quot; covid_economic_map_alternative Also, that depending on our preferences, we can easily remove the map frame, by using the “Frame” argument within the tm_layout function: # Removes frame from &quot;covid_economic_map_alternative&quot; map covid_economic_map_alternative&lt;-tm_shape(covid_economic_spatial_dataset)+ tm_polygons(col=&quot;mean_economic&quot;, n=5, style=&quot;equal&quot;, palette=&quot;YlOrRd&quot;)+ tm_layout(frame=FALSE) # Displays amended contents of &quot;covid_economic_map_alternative&quot; object (i.e. map without a frame) covid_economic_map_alternative 4.5.2 Customize Legend The biggest issue with the rough drafts of our map from the previous subsection is the position of the legend. Let’s go back to the first map we made (covid_economic_map), and simply switch its legend position, by specifying position=c(\"left\",\"bottom\") withing the tm_legend function: # Shifts legend position using the &quot;tm_legend&quot; function, and assigns amended map to &quot;covid_economic_map&quot; covid_economic_map&lt;-tm_shape(covid_economic_spatial_dataset)+ tm_polygons(col=&quot;mean_economic&quot;, n=8, style=&quot;jenks&quot;, palette=&quot;BuGn&quot;)+ tm_layout(frame=FALSE)+ tm_legend(position=c(&quot;left&quot;, &quot;bottom&quot;)) # Views amended contents of &quot;covid_economic_map&quot; covid_economic_map Currently, our legend is discrete, but we may want to try using a continuous legend to better match the continuous nature of the index (for more on discrete breaks vs continuous gradients, see here. We can do this by setting style=\"cont within the tm_polygons function: # Changes &quot;style&quot; argument parameter within &quot;tm_polygons&quot; function to &quot;cont&quot; to make continuous legend and assigns amended map to &quot;covid_economic_map&quot; (thereby overwriting the previous contents of &quot;covid_economic_map) covid_economic_map&lt;-tm_shape(covid_economic_spatial_dataset)+ tm_polygons(col=&quot;mean_economic&quot;, style=&quot;cont&quot;, palette=&quot;BuGn&quot;)+ tm_layout(frame=FALSE)+ tm_legend(position=c(&quot;left&quot;, &quot;bottom&quot;)) # Display amended map covid_economic_map Let’s explore some additional ways to customize our legend: Notice that the legend has a “Missing” category, to indicate countries for which we don’t have data on the Covid-19 economic index. Instead of labelling it “Missing” we’ll’ label it as “No Data”. Let’s give the legend a title that describes the data: “Mean of Covid Economic Intervention Index (1/1/2020 to 10/1/2020)”. It’s possible to experiment with different legend orientations. To see this, let’s flip the legend’s orientation, turning it into a horizontal rather than vertical bar. It’s also possible to specify our own intervals for the legend; we’ll set our legend breaks at 0, 0.25, 0.5, and 0.72. We’ll customize the size of our legend, as well as the legend’s text. We’ll alter the location of our legend, placing it outside the map’s bounding box (as defined by the now-invisible map frame) The following code incorporates these changes into the previous map: # Adds additional customizations to legend and assigns amended map to &quot;covid_economic_map&quot; (thereby overwriting the object&#39;s previous contents) covid_economic_map&lt;- tm_shape(covid_economic_spatial_dataset)+ tm_polygons(col=&quot;mean_economic&quot;, style=&quot;cont&quot;, palette=&quot;BuGn&quot;, textNA=&quot;No Data&quot;, title=&quot;Mean of Covid\\nEconomic\\nIntervention Index\\n(1/1/2020 to\\n 10/1/2020)&quot;, legend.is.portrait=FALSE, breaks=c(0,0.25,0.5, 0.72))+ tm_layout(legend.title.size=0.7, legend.title.fontface=2, legend.outside=TRUE, legend.outside.position = c(&quot;bottom&quot;), frame=FALSE, legend.text.size = 0.5, legend.width = 0.35) # Displays updated contents of &quot;covid_economic_map&quot; covid_economic_map Let’s unpack this code; for the sake of completeness, we’ll go over all of the functions and arguments, rather than just the code that implements the changes mentioned above. Above, to the right of the assignment operator, we have: tm_shape(covid_economic_spatial_dataset) specifies the spatial dataset that contains the information we want to map. The tm_polygons function takes many arguments here: col=\"mean_economic\" specifies the name of the column in covid_economic_spatial_dataset that contains the data we wish to map. style=cont indicates that we want a continuous legend palette=\"BuGn\" specifies the color scheme we wish to use to represent variation in the data. textNA=\"No Data indicates that we want data coded as “NA” to be labeled “No Data” in our legend; the default label is “Missing” title=\"Mean of Covid\\nEconomic\\nIntervention Index\\n(1/1/2020 to\\n 10/1/2020)\" specifies the title of the legend. The \\n notation is used to indicate line breaks. If these are not included, the legend title would not contain line breaks, and would be one line. . legend.is.portrait=FALSE flips the legend, making its orientation horizontal rather than vertical breaks=c(0,0.25,0.5,0.72) specifies our custom breaks (for values of the Covid economic index) in the legend. The tm_layout function also takes many arguments: legend.title.size=0.7 sets the size of the text in the legend’s title legend.title.fontface=2 makes the legend title bold. legend.outside=TRUE specifies that the legend is to be situated outside the (invisible) map frame; this prevents the legend from blocking out portions of the map itself legend.outside.position = c(\"bottom\") positions the legend below the southern border of the (invisible) map frame frame=FALSE makes the map frame invisible, so that we don’t see a border surrounding the countries legend.text.size=0.5 specifies the size of the legend text that is not part of the legend title legend.width=0.35 specifies the width of the legend The best way to get a sense of how all of these various arguments work is to change the values of the arguments and then inspect their effect on the map’s appearance. You will have an opportunity to try this in Practice Exercise 1 below (Section 5.1) 4.5.3 Add Map Title and Credits One useful thing to keep in mind is that when adding new elements to our map, it’s not necessary to retype all of our code; thus far, that is what we’ve been doing, but it’s also possible to simply append changes to an existing object. Below, to the right of the assignment operator, we first print the name of the object we want to modify (i.e. covid_economic_map) and then type a “+” sign; then, we can modify the object as desired through the use of relevant functions, and then save those changes by assigning the map back to covid_economic_map. In particular, we want to add and customize a map title (which we will do by passing a few additional arguments to the now-familiar tm_layout function), as well as add and customize a “Map Credits” section, which will include some basic map metadata. # Adds map credits and title to existing &quot;covid_economic_map&quot; object, and then assigns this amended map back to &quot;covid_economic_map&quot; (thereby overwriting the map that was previously assigned to this object) covid_economic_map&lt;-covid_economic_map+ tm_layout(main.title=&quot;Scope of National Economic Support Measures\\nin Response to the Covid-19 Pandemic&quot;, main.title.position=&quot;center&quot;, main.title.size=1, inner.margins=c(0.06,0.10,0.10,0.08), attr.outside = TRUE)+ tm_credits(&quot;Map Author: Aditya Ranganath\\nDataset Author: Simon Porcher\\nCRS: WGS1984\\nSource: ICPSR&quot;, position=c(0.78,0), size=0.38) # Display the amended &quot;covid_economic_map&quot; object covid_economic_map Let’s consider the new arguments passed through the tm_layout and tm_credits function: tm_layout main.title=\"Scope of National Economic Support Measures\\nin Response to the Covid-19 Pandemic\" specifies the title for the map as a whole. As before \\n specifies line breaks. main.title.position=\"center\" specifies the justification of the title main.title.size=1 specifies the font size of the title inner.margins=c(0.06,0.10,0.10,0.08) establishes the size of the margins within the map frame. Its most noticeable impact in this context is to regulate the whitespace between the title and the map features. attr.outside = TRUE, in this context, places the map credits (one of the map’s attributes), outside the map frame The tm_credits function is a function used to choose the content and appearance of the map’s credits section. \"Map Author: Aditya Ranganath\\nDataset Author: Simon Porcher\\nCRS: WGS1984\\nSource: ICPSR is the text of the credits section; as before, \\n specifies line breaks position=c(0.78,0) specifies the location of the credits size=0.38 specifies the size of the text in the credits section It’s worth emphasizing that when working on your these maps, a lot of trial-and-error is usually required in order to determine the values for the various function arguments that will yield a map with the desired appearance. In addition, there are a lot of tmap functions and arguments that we haven’t covered; be sure to explore all the possibilities by exploring tmap’s documentation (?tmap) 4.5.4 Final Map Code For convenience, here’s all of the code that we used to construct the map we arrived at in the previous section, along with comments summarizing what each line is doing: covid_economic_map&lt;- # assigns map to object named &quot;covid_econonmic_map&quot; tm_shape(covid_economic_spatial_dataset)+ # Specifies Spatial Dataset tm_polygons(col=&quot;mean_economic&quot;, # Specifies column we want to map style=&quot;cont&quot;, # Specifies continuous legend palette=&quot;BuGn&quot;, # Specifies color palette/scheme to represent data variation textNA=&quot;No Data&quot;, # Codes &quot;NA&quot; values as &quot;No Data&quot; in the legend title=&quot;Mean of Covid\\nEconomic\\nIntervention Index\\n(1/1/2020 to\\n 10/1/2020)&quot;, # Sets legend title legend.is.portrait=FALSE, # Makes legend horizontal breaks=c(0,0.25,0.5, 0.72))+ # Sets legend breaks tm_layout(legend.title.size=0.7, # Sets legend title size legend.title.fontface=2, # Makes legend bold legend.outside=TRUE, # Puts legend outside map frame legend.outside.position=c(&quot;bottom&quot;), # Puts legend below map frame frame=FALSE, # Makes map frame invisible legend.text.size = 0.5, # Sets size of legend tex legend.width=0.35, # Sets legend width main.title=&quot;Scope of National Economic Support Measures\\nin Response to the Covid-19 Pandemic&quot;, # Sets map title main.title.position=&quot;center&quot;, # Specifies title justification main.title.size=1, # Specifies title font size inner.margins=c(0.06,0.10,0.10,0.08), # Sets map margins with respect to frame attr.outside = TRUE)+ # Places map credits outside frame tm_credits(&quot;Map Author: Aditya Ranganath\\nDataset Author: Simon Porcher\\nCRS: WGS1984\\nSource: ICPSR&quot;, # Sets text for map credits position=c(0.78,0), # Specifies location of map credits size=0.38) # Specifies font size of credits text # Displays &quot;covid_economic_map&quot; object covid_economic_map 4.6 Export Map Once we’re done customizing our map, we can copy it to our clipboard (and paste it elsewhere), export it as an image file (i.e. png or jpeg), or export it as a PDF; we can either do this programatically using a built-in tmap function, or we can do it through the R Studio GUI. 4.6.1 Export Map Using tmap To export maps programmatically, we can use the tmap_save function. The first argument to this function should be the name of map object we want to export (here, covid_economic_map); the second should be the file name, including the extension, of the file to which we want to save the map object. If, for example, we wanted to save a png file with the name “covid_economic_map_export”, this second argument would be “covid_economic_map_export.png”. This is all we need in order to export the map (which will be saved in our working directory), but the tmap_save function allows several other arguments that you can learn about by inspecting the function’s documentation (?tmap_save). The only other arguments we’ll use are the “width” and “height” arguments, which allow us to specify the dimensions of the exported map (in pixels). We’ll export a map with width of 1920 pixels, and a height of 1080 pixels. The first code block below writes covid_economic_map as a png file (with dimensions of 1920 x 1080 pixels) to our working directory; the subsequent two blocks write the object as jpeg and PDF files, respectively. PNG File # Saves contents of &quot;covid_economic_map&quot; object as png file to working directory with resolution of 1920 by 1080 pixels tmap_save(covid_economic_map, &quot;covid_economic_map_export.png&quot;, width=1920, height=1080) JPEG File # Saves contents of &quot;covid_economic_map&quot; object as jpeg file to working directory with resolution of 1920 by 1080 pixels tmap_save(covid_economic_map, &quot;covid_map.jpeg&quot;, width=1920, height=1080) PDF File # Saves contents of &quot;covid_economic_map&quot; object as pdf file to working directory with resolution of 1920 by 1080 pixels tmap_save(covid_economic_map, &quot;covid_map.pdf&quot;, width=1920, height=1080) Once we’ve exported the map to our working directly in the format we’d like, we can open up the file on our computer. The PNG file will look something like this: Figure 4.10: Map Exported as Image File 4.6.2 Export Map Through GUI It’s also possible to export our map in the desired file format by using the “Export” menu bar within the “Plots” tab on the bottom-right of our R Studio interface. Click the “Export” button, and select one of the three options; from there, things should be self-explantory. Figure 4.11: Export Map Using R Studio GUI 4.7 Make a Dynamic Map So far, we’ve been making static print maps, which are a powerful tool of visualization; however, it’s also possible to make “dynamic” (or interactive) maps where you can pan across the map and zoom into areas of interest. Dynamic maps can therefore be a very useful tool for exploratory data analysis. In addition, tmap produces these dynamic maps as html output, which means we can embed these maps within web pages, which can be useful if a project involves a web-hosting component. To build such a dynamic map, simply build a map in tmap (just as we would build a static map) and assign it to an object. Then, use the tmap_mode function to set tmap to view mode. At this point, if we display the map object by printing its name, tmap will generate and display a dynamic map. As with the static maps created above, the dynamic map created by the code below uses a light green to dark green color scheme to show variation in the index, with lighter shades of green representing lower values of the mean economic policy intervention index, and darker shades of green representing higher values of the index. Oceans in the dynamic map are shown in grey (a lighter shade of grey than what is used for countries without data), and the vertically-oriented legend with discrete class breaks is located on the top-right of the map (above and to the right of Russia). The plus/minus buttons on the top-left of the map can be used to zoom in and out of the map. # Make map and assign it to an object named &quot;covid_economic_webmap&quot; (Same procedure as for static map) covid_economic_webmap&lt;-tm_shape(covid_economic_spatial_dataset)+ tm_polygons(col=&quot;mean_economic&quot;, n=5, style=&quot;jenks&quot;, palette=&quot;BuGn&quot;) # Set tmap mode to &quot;view tmap_mode(&quot;view&quot;) # display &quot;covid_economic_webmap&quot; in view mode covid_economic_webmap Within our R Studio interface, the dynamic map appears in the “Viewer” tab on the bottom-left window. To open the interactive map up in a larger window, click “Zoom”. Note that when we click on a country, the mean value of the index will pop out; we can also pan around the map and zoom into and out of areas of interest by clicking the large “+” and “-” buttons: Figure 4.12: Dynamic Map Within R Studio Interace It’s possible to customize dynamic maps to some degree, but not to the same extent as static maps. Consult tmap’s documentation for additional guidance. It’s possible to export dynamic maps as html files. To do so, we use the same tmap_save function as before, but instead specify an html extension. The html file will be written to our working directory: # Writes contents of &quot;covid_economic_webmap&quot; (i.e. the dynamic map) to working directory as html file tmap_save(covid_economic_webmap, &quot;covid_economic_webmap.html&quot;) Once it’s been saved, we can open up the interactive map in a web browser of choice: Figure 4.13: Saved Interactive Map Open in Browser We can switch back to “plot” mode, at which point tmap will go back to making static maps. # Switch back to plot mode tmap_mode(&quot;plot&quot;) We can toggle back and forth between “plot” mode and “view” mode as necessary, depending on whether we want to make a static or dynamic map. 4.8 Summary After working through the tutorial, it can be useful to see the essential steps required to generate our final print (i.e. static) and interactive maps in separate, self-contained scripts that summarize all of the steps we took above. Section 4.8.1. presents a summary version of our print map script, while 4.8.2. presents an analogous script that summarizes the code to make an interactive map (Note that many of the steps involved in making a dynamic map are exactly the same as the steps involved in making a print map). Note that the summary scripts below presuppose that we are in the correct working directory (i.e. the working directory which contains the ICPSR data we downloaded as an Excel file; see Section 3.6), and that all the required libraries are loaded (see Section 3.5) 4.8.1 Print Map Summary Script setwd(&quot;/Users/adityaranganath/Documents/git_repositories/icpsr_mapping_manual/tutorial_data&quot;) # Imports &quot;Dataset&quot; sheet from ICPSR Excel file into R Studio, and assigns the dataset to an object called &quot;covid_data&quot; covid_data&lt;-read_excel(&quot;Gov_Responses2Covid19_last.xlsx&quot;, sheet=&quot;Dataset&quot;) # Brings spatial dataset of country boundaries into R environment using the rnaturalearth package and assigns it to object named &quot;country_boundaries&quot; country_boundaries&lt;-ne_countries(scale=&quot;medium&quot;, returnclass=&quot;sf&quot;) # Deletes Antarctica from &quot;country_boundaries&quot; object country_boundaries&lt;-country_boundaries %&gt;% filter(iso_a3 !=&quot;ATA&quot;) # Selects &quot;iso&quot; and &quot;Economic_Measures&quot; variables from ICPSR Dataset, and assigns this new dataset to object named &quot;covid_data_economic&quot; covid_data_economic&lt;-covid_data %&gt;% select(iso, Economic_Measures) # Changes class of &quot;Economic_Measures&quot; field in &quot;covid_data_economic&quot; object from character to numeric covid_data_economic$Economic_Measures&lt;-as.numeric(covid_data_economic$Economic_Measures) # Calculates Country-Level Averages for &quot;Economic_Measures&quot; Index, and then assigns this dataset of country-level averages to a new object called &quot;covid_data_economic_avg&quot;. covid_data_economic_avg&lt;-covid_data_economic %&gt;% group_by(iso) %&gt;% summarize(mean_economic=mean(Economic_Measures, na.rm=FALSE)) # Joins dataset containing information on country-level means for &quot;Economic_Measures&quot; index (in &quot;covid_data_economic&quot; object) to spatial dataset of world boundaries (in &quot;country_boundaries&quot; object), based on common 3-Digit ISO Codes and assigns the dataset that results from this join to &quot;covid_economic_spatial_dataset&quot; covid_economic_spatial_dataset&lt;-full_join(country_boundaries, covid_data_economic_avg, by=c(&quot;iso_a3&quot;=&quot;iso&quot;)) # Make static map using data in &quot;covid_economic_spatial_dataset&quot; and assigns the map to object called &quot;covid_economic_map&quot; covid_economic_map&lt;- tm_shape(covid_economic_spatial_dataset)+ # Specifies Spatial Dataset containing data we want to map tm_polygons(col=&quot;mean_economic&quot;, # Specifies column we want to map style=&quot;cont&quot;, # Specifies continuous legend palette=&quot;BuGn&quot;, # Specifies color palette/scheme to represent data variation textNA=&quot;No Data&quot;, # Codes &quot;NA&quot; values as &quot;No Data&quot; in the legend title=&quot;Mean of Covid\\nEconomic\\nIntervention Index\\n(1/1/2020 to\\n 10/1/2020)&quot;, # Sets legend title legend.is.portrait=FALSE, # Makes legend horizontal breaks=c(0,0.25,0.5, 0.72))+ # Sets legend breaks tm_layout(legend.title.size=0.7, # Sets legend title size legend.title.fontface=2, # Makes legend bold legend.outside=TRUE, # Puts legend outside map frame legend.outside.position=c(&quot;bottom&quot;), # Puts legend below map frame frame=FALSE, # Makes map frame invisible legend.text.size = 0.5, # Sets size of legend tex legend.width=0.35, # Sets legend width main.title=&quot;Scope of National Economic Support Measures\\nin Response to the Covid-19 Pandemic&quot;, # Sets map title main.title.position=&quot;center&quot;, # Specifies title justification main.title.size=1, # Specifies title font size inner.margins=c(0.06,0.10,0.10,0.08), # Sets map margins with respect to frame attr.outside = TRUE)+ # Places map credits outside frame tm_credits(&quot;Map Author: Aditya Ranganath\\nDataset Author: Simon Porcher\\nCRS: WGS1984\\nSource: ICPSR&quot;, # Sets text for map credits position=c(0.78,0), # Specifies location of map credits size=0.38) # Specifies font size of credits text # Views &quot;covid_economic_map&quot; object covid_economic_map 4.8.2 Dynamic Map Summary Script The script below reproduces the dynamic web map generated in Section 4.7. The map created by the script uses a light green to dark green color scheme to show variation in the index, with lighter shades of green representing lower values of the mean economic policy intervention index, and darker shades of green representing higher values of the index. Oceans in the dynamic map are shown in grey (a lighter shade of grey than what is used for countries without data), and the vertically-oriented legend with discrete class breaks is located on the top-right of the map (above and to the right of Russia). The plus/minus buttons on the top-left of the map can be used to zoom in and out of the map. # Imports &quot;Dataset&quot; sheet from ICPSR Excel file into R Studio, and assigns the dataset to an object called &quot;covid_data&quot; covid_data&lt;-read_excel(&quot;Gov_Responses2Covid19_last.xlsx&quot;, sheet=&quot;Dataset&quot;) # Brings spatial dataset of country boundaries into R environment using the rnaturalearth package and assigns it to object named &quot;country_boundaries&quot; country_boundaries&lt;-ne_countries(scale=&quot;medium&quot;, returnclass=&quot;sf&quot;) # Deletes Antarctica from &quot;country_boundaries&quot; object country_boundaries&lt;-country_boundaries %&gt;% filter(iso_a3 !=&quot;ATA&quot;) # Selects &quot;iso&quot; and &quot;Economic_Measures&quot; variables from ICPSR Dataset, and assigns this new dataset to object named &quot;covid_data_economic&quot; covid_data_economic&lt;-covid_data %&gt;% select(iso, Economic_Measures) # Changes class of &quot;Economic_Measures&quot; field in &quot;covid_data_economic&quot; object from character to numeric covid_data_economic$Economic_Measures&lt;-as.numeric(covid_data_economic$Economic_Measures) # Calculates Country-Level Averages for &quot;Economic_Measures&quot; Index, and then assigns this dataset of country-level averages to a new object called &quot;covid_data_economic_avg&quot;. covid_data_economic_avg&lt;-covid_data_economic %&gt;% group_by(iso) %&gt;% summarize(mean_economic=mean(Economic_Measures, na.rm=FALSE)) # Joins dataset containing information on country-level means for &quot;Economic_Measures&quot; index (in &quot;covid_data_economic&quot; object) to spatial dataset of world boundaries (in &quot;country_boundaries&quot; object), based on common 3-Digit ISO Codes and assigns the dataset that results from this join to &quot;covid_economic_spatial_dataset&quot; covid_economic_spatial_dataset&lt;-full_join(country_boundaries, covid_data_economic_avg, by=c(&quot;iso_a3&quot;=&quot;iso&quot;)) %&gt;% relocate(name, mean_economic) # Makes map and assigns it to an object called &quot;covid_economic_webmap&quot; covid_economic_webmap&lt;-tm_shape(covid_economic_spatial_dataset)+ tm_polygons(col=&quot;mean_economic&quot;, n=5, style=&quot;jenks&quot;, palette=&quot;BuGn&quot;) # Sets tmap mode to &quot;view tmap_mode(&quot;view&quot;) # displays covid_economic_webmap in view mode covid_economic_webmap If we were to instead type filter(iso_a3==\"ATA), the function would only select the Antarctica row from the dataset and discard everything else.↩︎ It’s worth noting that when we are joining a tabular dataset to a spatial dataset with a view towards visualizing the information within the tabular data on a map, the spatial dataset should be listed before the tabular dataset. If we reverse this order, we’ll have to take some additional steps to get the joined dataset ready to map, and this is best avoided.↩︎ "],["practice-exercises.html", "5 Practice Exercises 5.1 Practice Exercise 1 5.2 Practice Exercise 2 5.3 Practice Exercise 3 5.4 Sample Code for Practice Exercises", " 5 Practice Exercises In this section you’ll have the opportunity to apply what you learned in the tutorial provided in Section 4, and practice some of your skills. The following three exercises are arrayed in order of increasing difficulty. 5.1 Practice Exercise 1 Modify the map we made in Section 4 in the following ways: Change the color scheme. What rationale informed your choice of this color scheme? Change the legend breaks. Why did you chose the legend breaks that you did? Replace your name with the current name in the “Map Credits” section. What spatial patterns do you notice in this map? Are there any patterns of clustering or dispersion that you find interesting? Do you notice anything surprising or unexpected? And, what future research questions might this map suggest? 5.2 Practice Exercise 2 Use the same dataset we used in Section 4, but this time please make an interactive map of the country-level average of the “Rigidity_Public_Health” variable. What spatial patterns do you notice in this map? Are there any patterns of clustering or dispersion that you find interesting? Do you notice anything surprising or unexpected? And, what future research questions might this map suggest? 5.3 Practice Exercise 3 Refer to the following dataset, entitled “Worldwide Index of IPRs [Intellectual Property Rights] in Agriculture, 1961-2018”, which is archived on ICPSR and authored by Mercedes Campi amd Alessandro Nuvolari. Download the dataset, and make a map that shows country-level variation in the “Total_Index” variable in the year 2018. 5.4 Sample Code for Practice Exercises The sample code in this section assumes you’ve already loaded all of the packages discussed in the tutorial, and have correctly set your working directory to the directory in which the dataset(s) are located. 5.4.1 Sample Code for Exercise 2 The code below results in a dynamic webmap that represents cross-national variation in the scope of countries’ public health interventions (as measured by cross-national variation country-level average of the “Rigidity_Public_Health” variable), during the January to October 2020 time frame. The map uses a light orange to dark red color scheme in which lighter shades of orange represent low values of the index, and progressively darker shades of orange and red represent higher values of the index. Oceans in the dynamic map are represented with the color grey (a lighter shade of grey than what is used for countries without data), and the legend is located on the top-right of the map (above and to the right of Russia). The plus/minus buttons located on the top-left of the map can be used to zoom in and out of the map. # Import &quot;Dataset&quot; sheet from ICPSR Excel file into R Studio, and assign the dataset to an object called &quot;covid_data&quot; covid_data&lt;-read_excel(&quot;Gov_Responses2Covid19_last.xlsx&quot;, sheet=&quot;Dataset&quot;) # Brings spatial dataset of country boundaries into R environment using the rnaturalearth package and assigns it to object named &quot;country_boundaries&quot; country_boundaries&lt;-ne_countries(scale=&quot;medium&quot;, returnclass=&quot;sf&quot;) # Deletes Antarctica from &quot;country_boundaries&quot; object country_boundaries&lt;-country_boundaries %&gt;% filter(iso_a3 !=&quot;ATA&quot;) # Selects &quot;iso&quot; and &quot;Rigidity_Public_Health&quot; variables from ICPSR Covid Dataset, and assigns this dataset to new object named &quot;covid_data_public_health&quot; covid_data_public_health&lt;-covid_data %&gt;% select(iso, Rigidity_Public_Health) # Changes class of &quot;Rigidity_Public_Health&quot; field in &quot;covid_data_public_health&quot; from character to numeric covid_data_public_health$Rigidity_Public_Health&lt;-as.numeric(covid_data_public_health$Rigidity_Public_Health) # Calculates country-level averages for &quot;Rigidity_Public_Health&quot; index, and then assigns this dataset of country-level averages to a new object called &quot;covid_data_PH_avg&quot;. covid_data_PH_avg&lt;-covid_data_public_health %&gt;% group_by(iso) %&gt;% summarize(mean_public_health=mean(Rigidity_Public_Health, na.rm=FALSE)) # Join dataset with country-level means for &quot;Rigidity_Public_Health&quot; index (&quot;covid_data_PH_avg&quot; ) to spatial dataset of world boundaries (&quot;country_boundaries&quot;), based on common 3-Digit ISO Codes; then relocate &quot;name&quot; and &quot;mean_economic&quot; fields to the beginning of the dataset so that they&#39;re displayed on the map worldmap_covid_data_PH&lt;-full_join(country_boundaries, covid_data_PH_avg, by=c(&quot;iso_a3&quot;=&quot;iso&quot;)) %&gt;% relocate(name, mean_public_health) # Make map and assign to new object called &quot;covid_PH_webmap&quot; covid_PH_webmap&lt;-tm_shape(worldmap_covid_data_PH)+ tm_polygons(col=&quot;mean_public_health&quot;, n=5, style=&quot;jenks&quot;, palette=&quot;Oranges&quot;) # Set tmap mode to &quot;view&quot; tmap_mode(&quot;view&quot;) # display map object in view mode covid_PH_webmap 5.4.2 Sample Code for Exercise 3 # Load Tabular Data and assign to object named &quot;IPR_data&quot; IPR_data&lt;-read_excel(&quot;Index_IPR_Agriculture.xlsx&quot;, sheet=&quot;Total_Index&quot;) View(IPR_data) # Load Spatial Data and assign to object named &quot;country_boundaries&quot; country_boundaries&lt;-ne_countries(scale=&quot;medium&quot;, returnclass=&quot;sf&quot;) View(country_boundaries) # Delete Antarctica from &quot;country_boundaries&quot; country_boundaries&lt;-country_boundaries %&gt;% filter(iso_a3 !=&quot;ATA&quot;) # Check class of Index field in &quot;IPR_data&quot; and confirm it&#39;s numeric class(IPR_data$`Total Index`) ## [1] &quot;numeric&quot; # Select 2018 Observations from &quot;IPR_data&quot; and assign to new object named &quot;IPR_data_2018&quot; IPR_data_2018&lt;-IPR_data %&gt;% filter(year==2018) # View &quot;IPR_data_2018&quot; in R Studio Data Viewer View(IPR_data_2018) # Join &quot;Datasets&quot;IPR_data-2018&quot; to &quot;country_boundaries&quot; based on common ISO codes, and then assign the product of the join to a new object named &quot;spatial_IPR_2018.&quot; spatial_IPR_2018&lt;-full_join(country_boundaries, IPR_data_2018, by=c(&quot;iso_a3&quot;=&quot;Country_code&quot;)) %&gt;% relocate(Country, &#39;Total Index&#39;) # Make map of variation in agricultural IPR index in 2018, and assign to new object named &quot;IPR_2018_map&quot; IPR_2018_map&lt;-tm_shape(spatial_IPR_2018)+ tm_polygons(col=&quot;Total Index&quot;, n=6, style=&quot;jenks&quot;, palette=&quot;PuBu&quot;, title=&quot;Agriculture IPR\\nIndex, 2018&quot;)+ tm_layout(frame=FALSE, legend.outside=TRUE, legend.outside.position=c(&quot;bottom&quot;), main.title = &quot;Strength of Intellectual Property Protection in Agriculture, 2018&quot;, main.title.position = &quot;Center&quot;, main.title.size=1, inner.margins=c(0.06,0.10,0.10,0.08), attr.outside=TRUE)+ tm_credits(&quot;Map Author: YOUR NAME\\nDataset Author: Mercedes Campi\\nCRS:WGS84\\nSource:ICPSR&quot;, position=c(0.78,0), size=0.38) # Open &quot;IPR_2018_map&quot; IPR_2018_map "],["conclusion.html", "6 Conclusion 6.1 Wrapping Up 6.2 Useful Reading and Resources 6.3 Final Considerations 6.4 Acknowledgement 6.5 References", " 6 Conclusion Congratulations on finishing the tutorial and the exercises! This section concludes and offers suggestions on further reading and useful resources to consult. 6.1 Wrapping Up We started the tutorial with a tabular dataset archived on ICPSR. That dataset provides crossnational information on governments’ public health and economic policies in response to the Covid-19 pandemic. When we first opened the dataset after downloading it from the ICPSR landing page, it looked something like this: Figure 6.1: The Original ICSPR Dataset in Excel There were no maps or visualizations provided with the original ICPSR dataset, but with a bit of work in R Studio, we used the information in the dataset to generate and export a choropleth map that looked something like this: Figure 6.2: Map Based on Variable in ICPSR Dataset This illustrates an important point: when exploring ICPSR data, we’re not limited to the materials provided by the author of a given dataset. We have the power to take this archived data, and represent it in novel ways that might further our understanding of the topics that we’re interested in. In the most general terms, this tutorial was fundamentally about how to go about this process in the context of spatial visualization. More specifically, we learned more about how to put archived ICPSR data stored in tabular datasets into geographic context by representing the information they contain on a map. Every dataset has its idiosyncrasies, but the general workflow we developed here is quite portable; as Practice Exercise 3 demonstrated, the workflow and code we developed in the tutorial can, with a bit of tinkering, be adapted to other ICPSR datasets as well. 6.2 Useful Reading and Resources The choropleth maps we generated were fairly basic, and could be refined or made made more aesthetically pleasing. They could also be made more sophisticated, through techniques like inserting inset maps. If you would like to further develop your spatial visualization and mapping skills, an excellent place to start is with the free and open-source book by Lovelace, Nowosad, and Muenchow (2021), entitled Geocomputation with R. The book is more than an introduction to making maps; it’s a comprehensive guide to spatial analysis and Geographic Information Systems more generally. 6.3 Final Considerations Finally, our focus in this tutorial was on generated choropleth world maps using ICPSR datasets. Of course, ICPSR has data at different geographic scales, and has a particularly large collection of United States-specific data. If you’re interested in making a map of US-specific ICPSR data, the usaboundaries package allows you to import a variety of spatial datasets corresponding to different US geographic divisions (i.e. state, county, zip codes etc.). You could join tabular ICPSR data to these spatial datasets in order to visualize them on a map, using a process that is similar to the one presented in this tutorial. Documentation for the usaboundaries package is available here. It’s important to note, however, that in certain cases, particularly when working with spatial data at finer scales, privacy and disclosure concerns (that do not arise in the context of aggregate global data) might become salient. It is therefore important to be sensitive to the ethical issues that might arise in the context of a given spatial project. If you would like to learn more about such issues, Haley et al (2016) provide a useful guide in the context of a discussion of geographically-explicit health data in public health studies. 6.4 Acknowledgement The repository used to initially create this teaching resource was generated from a bookdown template that is available here: https://github.com/jtr13/bookdown-template. 6.5 References Bivand, Roger and Colin Rundel. 2020. “rgeos: Interface to Geometry Engine-Open Source (‘GEOS’)”. R Package Version 0.5-5. https://CRAN.R-project.org/package=rgeos. Campi, Mercedes and Alessandro Nuvolari. 2020. “Worldwide Index of IPRs in Agriculture (1961-2018): Index_IPR_Agriculture.xlsx.” Ann Arbor, MI: Inter-university Consortium for Political and Social Research. https://doi.org/10.3886/E121001V1-43940. Esri. n.d. “Data Classification Methods.” Accessed September 28, 2021. https://pro.arcgis.com/en/pro-app/2.7/help/mapping/layer-properties/data-classification-methods.htm Esri ArcGIS Developer. n.d. “Class breaks vs continuous color.” Accessed October 28, 2021. https://developers.arcgis.com/javascript/latest/visualization/best-practices/classed-vs-continuous/. Frazier, Melanie. “R Color Cheatsheet.” Accessed September 28, 2021. https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf. Grolemund, Garrett. Hands-on Programming With R. https://rstudio-education.github.io/hopr/ Haley, Danielle F., Stephen A. Matthews, Hannah LF Cooper, Regine Haardorfer, Adaora A. Adimora, Gina M. Wingood, and Michael R. Kramer. 2016. “Confidentiality Considerations for Social Spatial Data on the Social Determinants of Health: Sexual and Reproductive Health Case Study.” Soc Sci Med 166: 49-56. 10.1016/j.socscimed.2016.08.009. Lovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2021 Geocomputation With R. https://geocompr.robinlovelace.net/. Mullen, Lincoln A. and Jordan Bratt. 2018. “USAboundaries: Historical and Contemporary Boundaries of the United States of America.” Journal of Open Source Software 3(23): 314. doi: 10.21105/joss.00314. Pebesma, Edzer. 2018. “Simple Features for R: Standardized Support for Spatial Vector Data.” The R Journal 10(1): 439-446. https://doi.org/10.32614/RJ-2018-009. Porcher, Simon. 2020. “Governments’ Responses to COVID-19 (Response2covid19)”. Ann Arbor, MI: Inter-university Consortium for Political and Social Research [distributor]. https://doi.org/10.3886/E119061V6. “R For Social Scientists: Setup.” 2018-2021. Data Carpentry. https://datacarpentry.org/r-socialsci/setup.html. South, Andy. 2017. “rnaturalearth: World Map Data from Natural Earth.” R Package Version 0.1.0 https://CRAN.R-project.org/package=rnaturalearth South, Andy. 2017.\"rnaturalearthdata: World Vector Map Data from Natural Earth Used in ‘rnaturalearth.’ R Package version 0.1.0. 0.1.0. https://CRAN.R-project.org/package=rnaturalearthdata. Tennekes, Martijn. 2018. “tmap: Thematic Maps in R.” Journal of Statistical Software 84(6): 1-39. https://doi.org/10.18637/jss.v084.i06. Wickham, Hadley and Jennifer Bryan. 2019. “readxl: Read Excel Files.” R Package version 1.3.1 https://CRAN.R-project.org/package=readxl Wickham, Hadley, Romain Francois, and Lionel Henry. 2020. “dplyr: A Grammar of Data Manipulation.” R Package version 1.0.2. https://CRAN.R-project.org/package=dplyr. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
